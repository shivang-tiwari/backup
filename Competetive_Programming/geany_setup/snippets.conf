# Geany's snippets configuration file for Shivang Tiwari

[Default]

[Special]
block_cursor={\n\t\n}
[C++]
# Templates
test=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
notest=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\t//cin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
ctest=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1,casen = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tcout << "Case #" << casen << ": ";\n\t\ttestcase();\n\t\tcasen++;\n\t}\n\treturn (0-0);\n}\n
tester=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define booga cerr << "booga" << endl\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#define safai(...) Clearing_out(__VA_ARGS__)\n\n\ntemplate <typename A, typename B>\n\tstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\n\tstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\n\tstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n\treturn '"' + s + '"';\n}\n\nstring to_string(char c) {\n\tstring s;\n\ts += c;\n\treturn s;\n}\n\nstring to_string(const char* s) {\n\treturn to_string((string) s);\n}\n \nstring to_string(bool b) {\n\treturn (b ? "1" : "0");\n}\n \nstring to_string(vector<bool> v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (int i = 0; i < static_cast<int>(v.size()); i++) {\n\tif (!first) {\n\t\tres += ", ";\n\t}\n\tfirst = false;\n\tres += to_string(v[i]);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n\tstring res = "";\n\tfor (size_t i = 0; i < N; i++) {\n\t\tres += static_cast<char>('0' + v[i]);\n\t}\n\treturn res;\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (const auto &x : v) {\n\t\tif (!first) {\n\t\t\tres += ", ";\n\t\t}\n\t\tfirst = false;\n\t\tres += to_string(x);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n\treturn "(" + to_string(p.first) + ", " + to_string(p.second) + ")";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tcerr << " " << to_string(H);\n\tdebug_out(T...);\n}\n\nvoid Clearing_out() { return; }\n\ntemplate <typename Head, typename... Tail>\nvoid Clearing_out(Head &H, Tail & ... T) {\n\tH.clear();\n\tClearing_out(T...);\n}\nofstream myfile;\n\nvoid testcase(){\n\t%cursor%\n}\n\n\nint main(){\n\tmyfile.open("test_details.txt");\n\tint tt = 1;\n\tcout << tt << endl;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
solve=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nclass solution{\n\tpublic:\n\tvoid testcase(){\n\t\t%cursor%\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tsolution solver;\n\t\tsolver.testcase();\n\t}\n\treturn (0-0);\n}\n
debug=#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n
basic=// हर हर महादेव\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\t%cursor%\n\treturn 0;\n}\n
modular=template <typename T>\nT inverse(T a, T m) {\n\tT u = 0, v = 1;\n\twhile (a != 0) {\n\t\tT t = m / a;\n\t\tm -= t * a; swap(a, m);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tassert(m == 1);\n\treturn u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tconstexpr Modular() : value() {}\n\ttemplate <typename U>\n\tModular(const U& x) {\n\t\tvalue = normalize(x);\n\t}\n\ttemplate <typename U>\n\tstatic Type normalize(const U& x) {\n\t\tType v;\n\t\tif (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n\t\telse v = static_cast<Type>(x % mod());\n\t\tif (v < 0) v += mod();\n\t\treturn v;\n\t}\n\tconst Type& operator()() const { return value; }\n\ttemplate <typename U>\n\texplicit operator U() const { return static_cast<U>(value); }\n\tconstexpr static Type mod() { return T::value; }\n\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n\tModular& operator++() { return *this += 1; }\n\tModular& operator--() { return *this -= 1; }\n\tModular operator++(int) { Modular result(*this); *this += 1; return result; }\n\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }\n\tModular operator-() const { return Modular(-value); }\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n\t\tasm(\n\t\t\t"divl %4; "\n\t\t\t: "=a" (d), "=d" (m)\n\t\t\t: "d" (xh), "a" (xl), "r" (mod())\n\t\t);\n\t\tvalue = m;\n#else\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tlong long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n\t\tvalue = normalize(value * rhs.value - q * mod());\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tvalue = normalize(value * rhs.value);\n\t\treturn *this;\n\t}\n\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\tfriend const Type& abs(const Modular& x) { return x.value; }\n\ttemplate <typename U>\n\tfriend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename U>\n\tfriend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename V, typename U>\n\tfriend V& operator>>(V& stream, Modular<U>& number);\n\tprivate: Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n\tassert(b >= 0);\n\tModular<T> x = a, res = 1;\n\tU p = b;\n\twhile (p > 0) {\n\t\tif (p & 1) res *= x;\n\t\tx *= x;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n\treturn number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n\treturn to_string(number());\n}\n \n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n\treturn stream << number();\n}\n \n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n\ttypename common_type<typename Modular<T>::Type, long long>::type x;\n\tstream >> x;\n\tnumber.value = Modular<T>::normalize(x);\n\treturn stream;\n}\n \n\n//using ModType = int;\n \n//struct VarMod { static ModType value; };\n//ModType VarMod::value;\n//ModType& md = VarMod::value;\n//using Mint = Modular<VarMod>;\n \nconstexpr int md = (int) 1e9 + 7;\n//constexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint power(int x,const long long int y){\n\treturn power(Mint(x),y);\n}\n/*\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\n\nconst int MXN = ;\n\nvoid prep(){ // Don't forget to call this to use nCr\n\tfact.resize(MXN);\n\tinv_fact.resize(MXN);\n\tfact[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfact[i] = fact[i-1]*i;\n\t}\n\tinv_fact[MXN-1] = power(fact[MXN-1],md-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinv_fact[i] = inv_fact[i+1]*(i+1);\n\t}\n}\n \n\nMint C(int n, int k) {\n\tif (k < 0 || k > n) {\n\t\treturn 0;\n\t}\n\twhile ((int) fact.size() < n + 1) {\n\t\tfact.push_back(fact.back() * (int) fact.size());\n\t\tinv_fact.push_back(1 / fact.back());\n\t}\n\treturn fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n*/\n
geometry=const double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n\nnamespace geometry { // geometry Library\n\tstruct Point {\n\t\tdouble x, y;\n\t\tPoint(){};\n\t\tPoint(double x_,double y_):x(x_),y(y_){};\n\t\tPoint operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n\t\tPoint operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n\t\tPoint operator*(const double b) const { return Point(x * b,y * b); }\n\t\tPoint operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n\t\tPoint operator/(const double b) const { return Point(x / b,y / b); }\n\t\tbool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n\t\tbool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n\t\tdouble norm(){ return x * x + y * y; }\n\t\tdouble arg(){ return atan2(x,y); }\n\t\tdouble abs(){ return sqrt(norm()); }\n\t\tPoint rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n\t\tPoint rotate90(){ return Point(-y,x); }\n\t\tfriend ostream& operator<<(ostream& os, Point& p){ return os<<p.x<<" "<< p.y; }\n\t\tfriend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n\t};\n\tstruct Line {\n\t\tPoint a, b;\n\t\tLine(){};\n\t\tLine(Point a_,Point b_):a(a_),b(b_){};\n\t\tfriend ostream& operator<<(ostream& os, Line& p){ return os<<"("<<p.a.x<<","<<p.a.y<<") to ("<<p.b.x<<","<<p.b.y<<")"; }\n\t\tfriend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n\t};\n\tstruct Segment {\n\t\tPoint a, b;\n\t\tSegment(){};\n\t\tSegment(Point a_,Point b_):a(a_),b(b_){};\n\t\tfriend ostream& operator<<(ostream& os, Segment& p){ return os<<"("<<p.a.x<<","<<p.a.y<<") to ("<<p.b.x<<","<<p.b.y<<")"; }\n\t\tfriend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n\t};\n\tstruct Circle {\n\t\tPoint p; double r;\n\t\tCircle(){};\n\t\tCircle(Point p_, double r_) : p(p_),r(r_){};\n\t};\n\ttypedef vector< Point > Polygon;\n\ttypedef vector< Segment > Segments;\n\ttypedef vector< Line > Lines;\n\ttypedef vector< Circle > Circles;\n\ttypedef pair< Point, Point > PointPoint;\n\t\n\tdouble cross(const Point& a,const Point& b){return a.x * b.y - a.y * b.x;}\n\tdouble dot(const Point& a,const Point& b){return a.x * b.x + a.y * b.y;}\n\tint ccw(const Point& a,Point b,Point c){b = b - a, c = c - a;if(cross(b,c) > EPS)return +1;if(cross(b,c) < -EPS)return -1;if(dot(b,c) < 0)return +2;if(b.norm() < c.norm())return -2;return 0;}\n\tPoint Projection(const Line& l, const Point& p){double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();return l.a + (l.a - l.b) * t;}\n\tPoint Projection(const Segment& l, const Point& p){double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();return l.a + (l.a - l.b) * t;}\n\tPoint Reflection(const Line& l, const Point& p){return p + (Projection( l, p) - p) * 2.0;}\n\tdouble Distance( const Line& l,const Point& p) {return (p - Projection( l, p)).abs();}\n\tbool Intersect(const Line& l, const Line& m){return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;}\n\tbool Intersect(const Line& l, const Segment& s){return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;}\n\tbool Intersect(const Line& l, const Point& p){return abs(ccw(l.a, l.b, p)) != -1;}\n\tbool Intersect(const Segment& s, const Segment& t){return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;}\n\tbool Intersect(const Segment& s, const Point& p){return ccw(s.a, s.b, p) == 0;}\n\tbool Intersect(const Circle& c,const Line& l){return Distance( l, c.p) <= c.r + EPS;}\n\tbool Intersect(const Circle& c,const Point& p){return abs( ( p - c.p).abs() - c.r ) < EPS;}\n\tint  Intersect(const Circle& c, const Segment& l){if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;if(( d1 < c.r - EPS && d2 > c.r + EPS )|| (d1 > c.r + EPS && d2 < c.r - EPS )) return 1;const Point h = Projection( l, c.p);if( dot( l.a - h, l.b - h) < 0) return 2;return 0;}\n\tbool Intersect(const Circle& a,const Circle& b){return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);}\n\tbool Intersect(const Polygon& Q,const Segment& l){for(int i = 0; i < (int)Q.size(); i++){if(Intersect(Segment(Q[i],Q[(i+1)%Q.size()]),l))return true;}return false;}\n\tdouble Distance(const Segment& s,const Point& p){Point r = Projection(s, p);if ( Intersect( s, r)) return ( r - p).abs();return min( ( s.a - p).abs(), ( s.b - p).abs());}\n\tdouble Distance(const Segment& a,const Segment& b){if(Intersect( a, b)) return 0;return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));}\n\tdouble Distance(const Line& l,const Line& m) {return Intersect( l, m) ? 0 : Distance( l, m.a);}\n\tdouble Distance(const Line& l,const Segment& s) {if (Intersect(l, s)) return 0;return min(Distance(l, s.a), Distance(l, s.b));}\n\tdouble Distance(const Point& a,const Point& b){ return ( a - b).abs();}\n\tPoint Crosspoint(const Segment& l,const Segment& m) { double A = cross(l.b - l.a, m.b - m.a);double B = cross(l.b - l.a, l.b - m.a);if (abs(A) < EPS && abs(B) < EPS) return m.a;return m.a + (m.b - m.a) * B / A;}\n\tPointPoint Crosspoint(const Circle& c,const Line l){Point hp = Projection( l, c.p), h =  hp - c.p;const double d2 = h.norm();Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();return PointPoint(hp - v, hp + v);}\n\tPointPoint Crosspoint(const Circle& c,const Segment& l) {Line aa = Line( l.a, l.b);if(Intersect(c, l) == 2) return Crosspoint(c, aa);PointPoint ret = Crosspoint(c, aa);if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;else ret.first = ret.second;return ret;}\n\tPointPoint Crosspoint(const Circle& c1,const Circle& c2){ double d = (c1.p - c2.p).abs();double s = (c1.r + c2.r + d) / 2;double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));double h = 2 * S / d;Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();double m = sqrt( c1.r * c1.r - h * h);return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);}\n\tbool parallel(const Line& a,const Line& b){return abs(cross( a.b - a.a, b.b - b.a)) < EPS;}\n\tbool orthogonal(const Line& a,const Line& b){return abs(dot( a.a - a.b, b.a - b.b)) < EPS;}\n\tint Contains(const Polygon& Q,const Point& p){bool in = false;for(int i = 0 ; i < (int)Q.size() ; i++ ){Point a = curr(Q,i) - p, b = next(Q,i) - p;if(a.y > b.y) swap(a,b);if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;}return in ? IN : OUT;}\n\tbool Contains(const Circle& c,const Point& p){return ( c.p - p).abs() < c.r + EPS;}\n\tdouble Area2(const Polygon& p){ double A = 0;for (int i = 0; i < (int)p.size(); ++i){A += cross(curr(p, i), next(p, i));}return A;}\n\tbool IsConvex(const Polygon& p){for(int i = 0; i < (int)p.size(); i++){if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;}return true;}\n\tPolygon convexHull(Polygon& p){ // Can contain multiple points on same line\n\t\tint n = p.size(), k = 0;\n\t\tif(n >= 3){\n\t\t\tsort( p.begin(), p.end());\n\t\t\tvector< Point > ch(2 * n);\n\t\t\tfor(int i = 0; i < n; ch[k++] = p[i++]){\n\t\t\t\twhile(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n\t\t\t\twhile(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n\t\t\t}\n\t\t\tch.resize( k - 1);\n\t\t\treturn ch;\n\t\t} else {\n\t\t\treturn p;\n\t\t}\n\t}\n};\nusing namespace geometry;\n#pragma message("While printing, cast into integer if necessary")\n
pragma=#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n

# Loops and conditionals
if=if(%cursor%)%block_cursor%
else=else{\n\t%cursor%\n}
while=while(%cursor%)%block_cursor%
for=for(int i = 0; i < %cursor%; i++)%block_cursor%
rev=for(int i = %cursor%; i >= 0; i--)%block_cursor%
forj=for(int j = 0; j < %cursor%; j++)%block_cursor%
revj=for(int j = %cursor%; j >= 0; j--)%block_cursor%
fork=for(int k = 0; k < %cursor%; k++)%block_cursor%
revk=for(int k = %cursor%; k >= 0; k--)%block_cursor%
permute=do{\n\t\n} while(next_permutation(%cursor%.begin(),%cursor%.end()));\n

# Data-types
ll=long long int 
ld=long double 
ull=unsigned long long int 
str=string 
pii=pair<int,int> 
pll= pair<ll,ll> 
vec=vector<%cursor%>
set=set<%cursor%>
multi=multiset<%cursor%>
pq=priority_queue<%cursor%>+
vi=vector<int> 
vll=vector<ll> 
vc=vector<char> 
vb=vector<bool> 
vs=vector<string> 
vpii=vector<pair<int,int>> 
vpll=vector<pair<ll,ll>> 
vvi=vector<vector<int>> 
vvll=vector<vector<ll>> 
vvc=vector<vector<char>> 
mpii=map<int,int> 
mpci=map<char,int> 

# Inputs
array=int n;\ncin >> n;\nvector<int> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
arrayll=int n;\ncin >> n;\nvector<ll> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
array2d=int n,m;\ncin >> n >> m;\nvector<vector<int>> a(n,vector<int>(m));\nfor(int i = 0; i < n; i++){\n\tfor(int j = 0; j < m; j++){\n\t\tcin >> a[i][j];\n\t}\n}\n
bord=int n,m;\ncin >> n >> m;\nvector<string> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
graph=int n,m;\ncin >> n >> m;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphw=int n,m;\ncin >> n >> m;\nvector<vector<pair<int,int>>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\t//graph[v].push_back({u,w});\n}\n
graphwg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\tgraph[v].push_back({u,w});\n}\n
tree=int n;\ncin >> n;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
treeg=cin >> n;\ngraph.resize(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
fileio=#ifdef shivang_ka_laptop\n\tfreopen("in.txt" , "r", stdin);\n\tfreopen("out.txt" ,"w", stdout);\n#endif\n
int128=std::ostream& operator<<(std::ostream& dest,__int128_t value){std::ostream::sentry s(dest); if (s){__uint128_t tmp = value < 0 ? -value : value; char buffer[128]; char* d = std::end(buffer);do{--d;*d = "0123456789"[tmp%10];tmp /= 10;} while (tmp != 0);if (value < 0) {-- d;*d = '-';}int len = std::end(buffer) - d;if (dest.rdbuf()->sputn(d,len) != len){dest.setstate(std::ios_base::badbit);}}return dest;}

# Structures
segtree=class segtree {\n public:\n\tint neutral = 0;\n\tstruct node {\n\t\t// don't forget to set default value (used for leaves)\n\t\t// not necessarily neutral element!\n\t\t%cursor%; // Set identity element\n\t\tint add = 0;\n\t\tvoid apply(int l, int r, int v) { // Value of a single node (used by build and update)\n\t\t\t%cursor%;\n\t\t\t//sum = v; \n\t\t}\n\t\tvoid push(int l, int r, int v) { // Lazy propogation (used by add)\n\t\t\t//sum += v*(r - l + 1); \n\t\t\t//add += v;\n\t\t}\n\t};\n\tnode unite(const node &a, const node &b) const { // Set combination operation\n\t\tnode res;\n\t\t%cursor%;\n\t\t//res.sum = a.sum + b.sum; \n\t\treturn res;\n\t}\n\tinline void push(int x, int l, int r) {\n\t\t//int y = (l + r) >> 1;\n\t\t//int z = x + ((y - l + 1) << 1);\n\t\t//if (tree[x].add != neutral) {\n\t\t\t//tree[x + 1].push(l, y, tree[x].add);\n\t\t\t//tree[z].push(y + 1, r, tree[x].add);\n\t\t\t//tree[x].add = neutral;\n\t\t//}\n\t\t\n\t\t// Don't forget to uncomment node.push\n\t}\n\tinline void pull(int x, int z) {\n\t\ttree[x] = unite(tree[x + 1], tree[z]);\n\t}\n\n\tint n;\n\tvector<node> tree;\n\tvoid build(int x, int l, int r) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y);\n\t\tbuild(z, y + 1, r);\n\t\tpull(x, z);\n\t}\n\ttemplate <typename M>\n\tvoid build(int x, int l, int r, const vector<M> &v) {\n\t\tif (l == r) {\n\t\t\ttree[x].apply(l, r, v[l]);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y, v);\n\t\tbuild(z, y + 1, r, v);\n\t\tpull(x, z);\n\t}\n\tnode find(int x, int l, int r, int lx, int rx) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\treturn tree[x];\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tnode res{};\n\t\tif (rx <= y) {\n\t\t\tres = find(x + 1, l, y, lx, rx);\n\t\t} else {\n\t\t\tif (lx > y) {\n\t\t\tres = find(z, y + 1, r, lx, rx);\n\t\t\t} else {\n\t\t\tres = unite(find(x + 1, l, y, lx, rx), find(z, y + 1, r, lx, rx));\n\t\t\t}\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\ttemplate <typename... M>\n\tvoid update(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].apply(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tupdate(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tupdate(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].push(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tadd(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tadd(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\tsegtree(int _n) : n(_n) {\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1);\n\t}\n\ttemplate <typename M>\n\tsegtree(const vector<M> &v) {\n\t\tn = v.size();\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1, v);\n\t}\n\tnode find(int p) { // value at index p\n\t\tassert(0 <= p && p <= n - 1);\n\t\treturn find(0, 0, n - 1, p, p);\n\t}\n\ttemplate <typename... M>\n\tvoid update(int lx, int rx, const M&... v) {\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tupdate(0, 0, n - 1, lx, rx, v...);\n\t}\n\t// All functions below\n\tvoid update(int i, int v){ // Sets value at index i to v\n\t\tassert(i >= 0 && i < n);\n\t\tupdate(i,i,v);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int lx, int rx, const M&... v) { // adds v to a[lx to rx]\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tadd(0, 0, n - 1, lx, rx, v...);\n\t}\n\tnode find(int lx, int rx) { // value of lx to rx\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\treturn find(0, 0, n - 1, lx, rx);\n\t}\n};\n
fenwick=template <typename T>\nclass fenwick {\n  public:\n\tvector<T> fenw;\n\tint n;\n\tconst T neutral = 0; // Neutral element\n\tfenwick(int _n) : n(_n) {\n\t\tfenw.resize(n,neutral);\n\t}\n\tvoid add(int x, T v) {\n\t\tassert(x < n && x >= 0);\n\t\twhile (x < n) {\n\t\t\tcombine(fenw[x],v);\n\t\t\tx |= (x + 1);\n\t\t}\n\t}\n\tT find(int x) {\n\t\tassert(x < n && x >= 0);\n\t\tT v = neutral;\n\t\twhile (x >= 0) {\n\t\t\tcombine(v,fenw[x]);\n\t\t\tx = (x & (x + 1)) - 1;\n\t\t}\n\t\treturn v;\n\t}\n\tT find(int l,int r) { // Don't forget to change this if using anything other than addition\n\t\treturn find(r) - (l == 0 ? neutral : find(l-1));\n\t}\n\tvoid combine(T &v, T val){\n\t\t%cursor%;\n\t\t//v += val;\n\t}\n};\n
sparse=template<class T>\nclass sparse{\n\tpublic:\n\tint N, LG;\n\tvector<vector<T>>spt;\n\tvector<int>lg;\n\tsparse(){}\n\tsparse(vector<T> &a){\n\t\tN = a.size();\n\t\tLG = 32 - __builtin_clz(std::max(N - 1, 1));\n\t\tspt.resize(N+1, vector<T>(LG+1));\n\t\tlg.resize(N + 5,0);\n\t\tfor(int i = 2;i <= N;i++)\n\t\t\tlg[i] = lg[i/2] + 1;\n\t\tbuild(a);\n\t}\n\tvoid build(vector<T> &a){\n\t\tfor(int i = 0;i < N;i++)\n\t\t\tspt[i][0] = a[i];\n\t\tfor(int j = 1;j <= LG;j++){\n\t\t\tint len = (1 << j), half = (1 << (j-1));\n\t\t\tfor(int i = 0;i + len <= N;i++)\n\t\t\t\tspt[i][j] = combine(spt[i][j-1],spt[i+half][j-1]);\n\t\t}\n\t}\n\tT find(int l, int r){ // For idempotent operations in O(1)\n\t\tassert(l <= r && l >= 0 && r <= N-1);\n\t\tint lgg = lg[r-l+1], len = (1<<lgg);\n\t\treturn combine(spt[l][lgg], spt[r-len+1][lgg]);\n\t}\n\tT query(int L, int R){ // For other operations in O(log n)\n\t\tT answer = 0;\n\t\tfor (int j = LG; j >= 0; j--) {\n\t\t\tif (L + (1 << j) - 1 <= R) {\n\t\t\t\tanswer = combine(answer,spt[L][j]);\n\t\t\t\tL += 1 << j;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\tT combine(T x,T y){\n\t\treturn %cursor%;\n\t}\n};\n
lca=class LCA{\n\ttemplate<typename T>\n\tstruct SparseTable{\n\t\tvector<vector<T>> table;\n\t\tvector<int> logtable;\n\t\tfunction<T(T, T)> merge_func;\n\t\tSparseTable(){}\n\t\tSparseTable(const vector<T> &vec, const function<T(T, T)> &f): merge_func(f){\n\t\t\tint maxlength = 0;\n\t\t\twhile((1 << (maxlength+1)) <= (int)vec.size()) maxlength++;\n\t\t\ttable.resize(maxlength+1, vector<T>(vec.size()));\n\t\t\tlogtable.resize(vec.size()+1);\n\t\t\tfor(int i = 0;i < maxlength + 1;i++){\n\t\t\t\tfor(int j = 0;j < (int)vec.size() - (1 << i) + 1;j++){\n\t\t\t\t\tif(i)table[i][j] = merge_func(table[i-1][j], table[i-1][j + (1 << (i-1))]);\n\t\t\t\t\telse table[i][j] = vec[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 2;i <= (int)vec.size();i++)logtable[i] = logtable[i >> 1]+1;\n\t\t}\n\t\tT query(int l, int r){\n\t\t\tassert(l < r);\n\t\t\tint length = r - l;\n\t\t\treturn merge_func(table[logtable[length]][l], table[logtable[length]][r - (1 << logtable[length])]);\n\t\t}\n\t};\n\tprivate:\n\tint a = 0, b = 0;\n\tvector<int> begin, number, tour, dep, rev;\n\tSparseTable<int> table;\n\tvoid init_dfs(int v, int p, const vector<vector<int>> &g){\n\t\tnumber[v] = b;rev[b] = v;b++;\n\t\tfor(auto t : g[v]){\n\t\t\tif(t == p) continue;\n\t\t\tdep[t] = dep[v] + 1;\n\t\t\tinit_dfs(t, v, g);\n\t\t\ttour.push_back(number[v]);\n\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t\ta++;\n\t\t}\n\t\tif(begin[v] == -1)begin[v] = a;\n\t}\n\tpublic:\n\t//initialization O(NlogN)\n\tLCA(const vector<vector<int>> &g, int root = 0):begin(g.size(), -1), number(g.size()), dep(g.size(), -1), rev(g.size()){\n\t\tdep[root] = 0;\n\t\tinit_dfs(root, -1, g);\n\t\ttable = SparseTable<int>(tour, [](int x, int y){return min(x, y);});\n\t}\n\t//O(1) per query\n\tint lca(int u, int v){\n\t\tif(begin[u] == begin[v]) return (dep[u] > dep[v] ? v : u);\n\t\tif(begin[u] > begin[v]) swap(u, v);\n\t\t\treturn rev[table.query(begin[u], begin[v]+1)];\n\t}\n\tint depth(int v){\n\t\treturn dep[v];\n\t}\n\tint dist(int u, int v){\n\t\treturn dep[u] + dep[v] - 2*dep[lca(u, v)];\n\t}\n};\n
hld=class HLD{\n\tclass LCA{\n\t\ttemplate<typename T>\n\t\tstruct SparseTable{\n\t\t\tvector<vector<T>> table;\n\t\t\tvector<int> logtable;\n\t\t\tfunction<T(T, T)> merge_func;\n\t\t\tSparseTable(){}\n\t\t\tSparseTable(const vector<T> &vec, const function<T(T, T)> &f): merge_func(f){\n\t\t\t\tint maxlength = 0;\n\t\t\t\twhile((1 << (maxlength+1)) <= (int)vec.size()) maxlength++;\n\t\t\t\ttable.resize(maxlength+1, vector<T>(vec.size()));\n\t\t\t\tlogtable.resize(vec.size()+1);\n\t\t\t\tfor(int i = 0;i < maxlength + 1;i++){\n\t\t\t\t\tfor(int j = 0;j < (int)vec.size() - (1 << i) + 1;j++){\n\t\t\t\t\t\tif(i)table[i][j] = merge_func(table[i-1][j], table[i-1][j + (1 << (i-1))]);\n\t\t\t\t\t\telse table[i][j] = vec[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 2;i <= (int)vec.size();i++)logtable[i] = logtable[i >> 1]+1;\n\t\t\t}\n\t\t\tT query(int l, int r){\n\t\t\t\tassert(l < r);\n\t\t\t\tint length = r - l;\n\t\t\t\treturn merge_func(table[logtable[length]][l], table[logtable[length]][r - (1 << logtable[length])]);\n\t\t\t}\n\t\t};\n\t\tprivate:\n\t\tint a = 0, b = 0;\n\t\tvector<int> begin, number, tour, dep, rev;\n\t\tSparseTable<int> table;\n\t\tvoid init_dfs(int v, int p, const vector<vector<int>> &g){\n\t\t\tnumber[v] = b;rev[b] = v;b++;\n\t\t\tfor(auto t : g[v]){\n\t\t\t\tif(t == p) continue;\n\t\t\t\tdep[t] = dep[v] + 1;\n\t\t\t\tinit_dfs(t, v, g);\n\t\t\t\ttour.push_back(number[v]);\n\t\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t}\n\t\tpublic:\n\t\tLCA(){}\n\t\t//initialization O(NlogN)\n\t\tLCA(const vector<vector<int>> &g, int root = 0):begin(g.size(), -1), number(g.size()), dep(g.size(), -1), rev(g.size()){\n\t\t\tdep[root] = 0;\n\t\t\tinit_dfs(root, -1, g);\n\t\t\ttable = SparseTable<int>(tour, [](int x, int y){return min(x, y);});\n\t\t}\n\t\t//O(1) per query\n\t\tint lca(int u, int v){\n\t\t\tif(begin[u] == begin[v]) return (dep[u] > dep[v] ? v : u);\n\t\t\tif(begin[u] > begin[v]) swap(u, v);\n\t\t\t\treturn rev[table.query(begin[u], begin[v]+1)];\n\t\t}\n\t\tint depth(int v){\n\t\t\treturn dep[v];\n\t\t}\n\t\tint dist(int u, int v){\n\t\t\treturn dep[u] + dep[v] - 2*dep[lca(u, v)];\n\t\t}\n\t};\n\t\n\tclass segtree {\n\t public:\n\t\tint neutral = 0;\n\t\tstruct node {\n\t\t\t// don't forget to set default value (used for leaves)\n\t\t\t// not necessarily neutral element!\n\t\t\t%cursor%; // Set identity element\n\t\t\tint add = 0;\n\t\t\tvoid apply(int l, int r, int v) { // Value of a single node (used by build and update)\n\t\t\t\t%cursor%;\n\t\t\t\t//sum = v; \n\t\t\t}\n\t\t\tvoid push(int l, int r, int v) { // Lazy propogation (used by add)\n\t\t\t\t//sum += v*(r - l + 1); \n\t\t\t\t//add += v;\n\t\t\t}\n\t\t};\n\t\tnode unite(const node &a, const node &b) const { // Set combination operation\n\t\t\tnode res;\n\t\t\t%cursor%;\n\t\t\t//res.sum = a.sum + b.sum; \n\t\t\treturn res;\n\t\t}\n\t\tinline void push(int x, int l, int r) {\n\t\t\t//int y = (l + r) >> 1;\n\t\t\t//int z = x + ((y - l + 1) << 1);\n\t\t\t//if (tree[x].add != neutral) {\n\t\t\t\t//tree[x + 1].push(l, y, tree[x].add);\n\t\t\t\t//tree[z].push(y + 1, r, tree[x].add);\n\t\t\t\t//tree[x].add = neutral;\n\t\t\t//}\n\t\t\t\n\t\t\t// Don't forget to uncomment node.push\n\t\t}\n\t\tinline void pull(int x, int z) {\n\t\t\ttree[x] = unite(tree[x + 1], tree[z]);\n\t\t}\n\t\n\t\tint n;\n\t\tvector<node> tree;\n\t\tvoid build(int x, int l, int r) {\n\t\t\tif (l == r) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tbuild(x + 1, l, y);\n\t\t\tbuild(z, y + 1, r);\n\t\t\tpull(x, z);\n\t\t}\n\t\ttemplate <typename M>\n\t\tvoid build(int x, int l, int r, const vector<M> &v) {\n\t\t\tif (l == r) {\n\t\t\t\ttree[x].apply(l, r, v[l]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tbuild(x + 1, l, y, v);\n\t\t\tbuild(z, y + 1, r, v);\n\t\t\tpull(x, z);\n\t\t}\n\t\tnode find(int x, int l, int r, int lx, int rx) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\treturn tree[x];\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tnode res{};\n\t\t\tif (rx <= y) {\n\t\t\t\tres = find(x + 1, l, y, lx, rx);\n\t\t\t} else {\n\t\t\t\tif (lx > y) {\n\t\t\t\tres = find(z, y + 1, r, lx, rx);\n\t\t\t\t} else {\n\t\t\t\tres = unite(find(x + 1, l, y, lx, rx), find(z, y + 1, r, lx, rx));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid update(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\ttree[x].apply(l, r, v...);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tif (lx <= y) {\n\t\t\t\tupdate(x + 1, l, y, lx, rx, v...);\n\t\t\t}\n\t\t\tif (rx > y) {\n\t\t\t\tupdate(z, y + 1, r, lx, rx, v...);\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid add(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\ttree[x].push(l, r, v...);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tif (lx <= y) {\n\t\t\t\tadd(x + 1, l, y, lx, rx, v...);\n\t\t\t}\n\t\t\tif (rx > y) {\n\t\t\t\tadd(z, y + 1, r, lx, rx, v...);\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t}\n\t\tsegtree(){}\n\t\tsegtree(int _n) : n(_n) {\n\t\t\tassert(n > 0);\n\t\t\ttree.resize(2 * n - 1);\n\t\t\tbuild(0, 0, n - 1);\n\t\t}\n\t\ttemplate <typename M>\n\t\tsegtree(const vector<M> &v) {\n\t\t\tn = v.size();\n\t\t\tassert(n > 0);\n\t\t\ttree.resize(2 * n - 1);\n\t\t\tbuild(0, 0, n - 1, v);\n\t\t}\n\t\tnode find(int p) { // value at index p\n\t\t\tassert(0 <= p && p <= n - 1);\n\t\t\treturn find(0, 0, n - 1, p, p);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid update(int lx, int rx, const M&... v) {\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\tupdate(0, 0, n - 1, lx, rx, v...);\n\t\t}\n\t\tvoid add(int i, int v){\n\t\t\tassert(i >= 0 && i < n);\n\t\t\tadd(i,i,v);\n\t\t}\n\t\t// All functions below\n\t\tvoid update(int i, int v){ // Sets value at index i to v\n\t\t\tassert(i >= 0 && i < n);\n\t\t\tupdate(i,i,v);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid add(int lx, int rx, const M&... v) { // adds v to a[lx to rx]\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\tadd(0, 0, n - 1, lx, rx, v...);\n\t\t}\n\t\tnode find(int lx, int rx) { // value of lx to rx\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\treturn find(0, 0, n - 1, lx, rx);\n\t\t}\n\t};\n\t\n\tpublic:\n\tint N;\n\tvector<vector<int>> adj;\n\tvector<int> a;\n\tvector<int> label;\n\tvector<int> par;\n\tvector<int> depth;\n\tvector<int> siz;\n\tvector<int> heavy;\n\tvector<int> chain_head;\n\tint tim;\n\tbool leave_lca;\n\tLCA lca;\n\tsegtree tr;\n\tHLD(const vector<vector<int>> &G,const vector<int> &values,bool _leave_lca){\n\t\tadj = G;\n\t\ta = values;\n\t\tN = G.size();\n\t\tlabel.resize(N);\n\t\tdepth.resize(N);\n\t\tpar.resize(N,-1);\n\t\tsiz.resize(N);\n\t\theavy.resize(N,-1);\n\t\tchain_head.resize(N,-1);\n\t\tiota(chain_head.begin(),chain_head.end(),0);\n\t\ttim = 0;\n\t\tleave_lca = _leave_lca;\n\t\tlca = LCA(adj);\n\t\ttr = segtree(N);\n\t\tsub_dfs(0);\n\t\tlabel_dfs(0);\n\t\tchain_dfs(0);\n\t}\n\tvoid sub_dfs(int i,int parent = -1){\n\t\tpar[i] = parent;\n\t\tsiz[i] = 1;\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent){\n\t\t\t\tdepth[v] = 1 + depth[i];\n\t\t\t\tsub_dfs(v,i);\n\t\t\t\tsiz[i] += siz[v];\n\t\t\t\tif(heavy[i] == -1 || siz[heavy[i]] < siz[v]){\n\t\t\t\t\theavy[i] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid label_dfs(int i,int parent = -1){\n\t\ttr.update(tim,a[i]);\n\t\tlabel[i] = tim++;\n\t\tif(heavy[i] != -1)label_dfs(heavy[i],i);\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent && v != heavy[i]){\n\t\t\t\tlabel_dfs(v,i);\n\t\t\t}\n\t\t}\n\t}\n\tvoid chain_dfs(int i,int parent = -1){\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent){\n\t\t\t\tif(v == heavy[i]){\n\t\t\t\t\tchain_head[v] = chain_head[i];\n\t\t\t\t}\n\t\t\t\tchain_dfs(v,i);\n\t\t\t}\n\t\t}\n\t}\n\t// All functions below\n\tsegtree::node find(int u,int v,int flag = -1){\n\t\tif(flag == -1){\n\t\t\tflag = leave_lca;\n\t\t}\n\t\tsegtree::node res;\n\t\tif(u == v){\n\t\t\treturn (flag ? res : tr.find(label[u],label[u]));\n\t\t}\n\t\tint lc = lca.lca(u,v);\n\t\tif(flag){\n\t\t\twhile(depth[u] > depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tif(where == lc){\n\t\t\t\t\tres = tr.unite(res,tr.find(label[where]+1,label[u]));\n\t\t\t\t\tu = lc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\t\tu = par[where];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\twhile(u != -1 && depth[u] >= depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\tu = v;\n\t\twhile(depth[u] > depth[lc]){\n\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\tif(where == lc){\n\t\t\t\tres = tr.unite(res,tr.find(label[where]+1,label[u]));\n\t\t\t\tu = lc;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid update(int i,int v){\n\t\ttr.update(label[i],v);\n\t}\n\tvoid add(int u,int v,int x, int flag = -1){\n\t\tif(flag == -1)flag = leave_lca;\n\t\tif(u == v){\n\t\t\tif(flag)return;\n\t\t\ttr.add(label[u],label[u],x);\n\t\t\treturn;\n\t\t}\n\t\tint lc = lca.lca(u,v);\n\t\tif(flag){\n\t\t\twhile(depth[u] > depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tif(where == lc){\n\t\t\t\t\ttr.add(label[where]+1,label[u],x);\n\t\t\t\t\tu = lc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\t\tu = par[where];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\twhile(u != -1 && depth[u] >= depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\tu = v;\n\t\twhile(depth[u] > depth[lc]){\n\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\tif(where == lc){\n\t\t\t\ttr.add(label[where]+1,label[u],x);\n\t\t\t\tu = lc;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Set third argument to FALSE for vertex queries and TRUE for edge queries\n
ordset=#include <bits/extc++.h>\nusing namespace __gnu_pbds;\ntemplate <typename A, typename B = std::less <A>> using ordered_set = tree <A, null_type, B, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename A, typename B, typename C = std::less <A>> using ordered_map = tree <A, B, C, rb_tree_tag, tree_order_statistics_node_update>;\n//order_of_key (k) : Number of items strictly smaller than k\n//find_by_order(k) : K-th element in a set (counting from zero)\n
dsu=struct dsu{\n\tint n;\n\tvector<int> parent;\n\tvector<int> siz;\n\tdsu(int sz) : n(sz){\n\t\tparent.resize(n);\n\t\tsiz.resize(n,1);\n\t\tiota(parent.begin(),parent.end(), 0);\n\t}\n\tinline bool cmp(int a, int b){ // Give indices here\n\t\treturn siz[a] < siz[b];\n\t}\n\tinline int find(int x){ // Give index here\n\t\tassert(x >= 0 && x < n);\n\t\twhile (x != parent[x]) x = parent[x] = parent[parent[x]];\n\t\treturn x;\n\t}\n\tbool combine(int a, int b){ // Give indices here, (returns true if a and b are in different sets)\n\t\tassert(min(a,b) >= 0 && max(a,b) < n);\n\t\tif((a = find(a)) != (b = find(b))){\n\t\t\tif(cmp(a,b))swap(a,b);\n\t\t\tparent[b] = a;\n\t\t\tsiz[a] += siz[b];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tinline bool same(int a,int b){ // Returns true if a and b are in same set\n\t\tassert(min(a,b) >= 0 && max(a,b) < n);\n\t\treturn find(a) == find(b);\n\t}\n\tinline int size(int x){ // Returns the size of the set containing x\n\t\tassert(x >= 0 && x < n);\n\t\treturn siz[find(x)];\n\t}\n};\n
strhash=template<typename T_string = string,typename hash_type = int64_t>\nstruct string_hash{\n\tint N;\n\tstring s;\n\tconst int p = 31; // lowercase\n\t//const int p = 53; // lower + upper\n\t\n\tconst int start = 'a';\n\t\n\tconst hash_type MOD = 1e9 + 9;\n\t\n\tvector<hash_type> hsh;\n\tvector<hash_type> rev;\n\t\n\tstring_hash(T_string str){\n\t\tN = str.size();\n\t\thsh.resize(N);\n\t\trev.resize(N);\n\t\ts = str;\n\t\thash_type yet = 0;\n\t\thash_type pp = 1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\t(yet += pp * (s[i] - start + 1)) %= MOD;\n\t\t\t(pp *= p) %= MOD;\n\t\t\thsh[i] = yet;\n\t\t}\n\t\tpp = 1;\n\t\tyet = 0;\n\t\tfor(int i = N-1; i >= 0; i--){\n\t\t\t(yet += pp * (s[i] - start + 1)) %= MOD;\n\t\t\t(pp *= p) %= MOD;\n\t\t\trev[i] = yet;\n\t\t}\n\t}\n\thash_type find_hash(int l,int r){\n\t\tif(l <= r){\n\t\t\tassert(l >= 0 && r < N);\n\t\t\thash_type res = ((hsh[r] - (l == 0 ? 0 : hsh[l-1])) * inv(power(p,l))) % MOD;\n\t\t\treturn res < 0 ? res + MOD : res;\n\t\t}\n\t\telse{\n\t\t\tswap(l,r);\n\t\t\tassert(l >= 0 && r < N);\n\t\t\thash_type res = ((rev[l] - (r == N-1 ? 0 : rev[r+1])) * inv(power(p,N-r-1))) % MOD;\n\t\t\treturn res < 0 ? res + MOD : res;\n\t\t}\n\t\t\n\t}\n\thash_type find_hash_scaled(int l,int r){ // Does not divide, scales the string to N\n\t\tif(l <= r){\n\t\t\tassert(l >= 0 && r < N);\n\t\t\thash_type res = ((hsh[r] - (l == 0 ? 0 : hsh[l-1])) * power(p,N-r-1)) % MOD;\n\t\t\treturn res < 0 ? res + MOD : res;\n\t\t}\n\t\telse{\n\t\t\tswap(l,r);\n\t\t\tassert(l >= 0 && r < N);\n\t\t\thash_type res = ((rev[l] - (r == N-1 ? 0 : rev[r+1])) * power(p,l)) % MOD;\n\t\t\treturn res < 0 ? res + MOD : res;\n\t\t}\n\t\t\n\t}\n\thash_type power(hash_type x, hash_type y){\n\t\thash_type res = 1;\n\t\tx = x % MOD;\n\t\tif (x == 0) return 0;\n\t\twhile (y > 0){\n\t\t\tif (y & 1)\n\t\t\t\tres = (res*x) % MOD;\n\t\t\ty = y >> 1;\n\t\t\tx = (x*x) % MOD;\n\t\t}\n\t\treturn res;\n\t}\n\thash_type inv(hash_type x){\n\t\tx %= MOD;\n\t\tassert(x != 0);\n\t\treturn power(x,MOD-2);\n\t}\n\thash_type divi(hash_type x,hash_type y){\n\t\tx %= MOD;\n\t\ty %= MOD;\n\t\treturn (x * inv(y)) % MOD;\n\t}\n\t\n\tbool palindrome(int l = 0,int r = -1){\n\t\tif(r == -1){\n\t\t\tr = N-1;\n\t\t}\n\t\treturn find_hash_scaled(l,r) == find_hash_scaled(r,l);\n\t}\n};\n\ntemplate<typename T_string = string,typename hash_type = int64_t>\nbool same(const string_hash<T_string,hash_type> &v1, int l1,int r1, const string_hash<T_string,hash_type> &v2,int l2,int r2){ // v1[l1, ... ,r1] == v2[l2 , ... ,r2]\n\tif(max(l1,r1) - min(l1,r1) != max(l2,r2) - min(l2,r2)){\n\t\treturn false;\n\t}\n\treturn v1.find_hash_scaled(l1,r1) == v2.find_hash_scaled(l2,r2);\n}\n\ntemplate<typename T_string = string,typename hash_type = int64_t>\nhash_type concat(string_hash<T_string,hash_type> &v1, int l1,int r1, string_hash<T_string,hash_type> &v2,int l2,int r2){ // concatenates v1[l1, ... ,r1] and v2[l2, ... ,r2]\n\tassert(v1.MOD == v2.MOD);\n\tassert(v1.p == v2.p);\n\thash_type res = v2.find_hash(l2,r2);\n\t(res *= v1.power(v1.p,max(r1,l1)-min(r1,l1)+1)) %= v1.MOD;\n\treturn (res + v1.find_hash(l1,r1)) % v1.MOD;\n}\n\n// hash(s) = s[0] + p*s[1] + p^2*s[2] + ... + p^(n-1) s[n-1]\n
cst=template<typename T>\nstruct cst{ // const is important\n\tbool operator()(const T& v1, const T& v2) const {\n\t\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n\t}\n};\n


# Algorithms
dijkstra=vector<long long int> dist;\nvector<int> pre;\nvoid dijkstra(int start,vector<vector<pair<int,int>>> &adj){\n\tdist.clear();dist.resize(adj.size(),1e18);\n\tpre.clear();pre.resize(adj.size(),-1);\n\tpriority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> que;\n\tque.push({dist[start] = 0, start});\n\twhile (!que.empty()) {\n\t\tauto top = que.top();\n\t\tque.pop();\n\t\tif (top.first != dist[top.second]) continue;\n\t\tfor(auto node : adj[top.second])\n\t\t\tif(dist[node.first] > top.first + node.second) \n\t\t\t\tque.push({dist[node.first] = top.first + node.second, node.first}), pre[node.first] = top.second;\n\t}\n}\n
dijkstrau=vector<int> pre;\nvector<int> dist;\nvoid dijkstra(int start,vector<vector<int>> &adj){\n\tdist.clear();dist.resize(adj.size(),1e9 + 50);\n\tpre.clear();pre.resize(adj.size(),-1);\n\tqueue<pair<int,int>> que;\n\tque.push({dist[start] = 0, start});\n\twhile (!que.empty()) {\n\t\tauto top = que.front();\n\t\tque.pop();\n\t\tif (top.first != dist[top.second]) continue;\n\t\tfor(auto node : adj[top.second])\n\t\t\tif(dist[node] > top.first + 1) \n\t\t\t\tque.push({dist[node] = top.first + 1, node}), pre[node] = top.second;\n\t}\n}\n
bpcheck=vector<int> col;\nbool bpcheck(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tcol.clear();col.resize(V,-1);\n\tqueue<pair<int,int>> q;\n\tfor(int i = 0; i < V; i++){\n\t\tif(col[i] == -1) {\n\t\t\tq.push({i,0});\n\t\t\tcol[i] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpair<int,int> p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint v = p.first;\n\t\t\t\tint c = p.second;\n\t\t\t\tfor(int j : adj[v]){\n\t\t\t\t\tif(col[j] == c)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif(col[j] == -1){\n\t\t\t\t\t\tcol[j] = c ^ 0 ^ 1;\n\t\t\t\t\t\tq.push({j, col[j]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n
bpm=class bpm {\n\tpublic:\n\tvector< vector<int> > g;\n\tvector<int> pa;\n\tvector<int> pb;\n\tvector<int> was;\n\tint n, m;\n\tint res;\n\tint iter;\n\tbpm(int _n, int _m) : n(_n), m(_m){\n\t\tassert(0 <= n && 0 <= m);\n\t\tpa = vector<int>(n, -1);\n\t\tpb = vector<int>(m, -1);\n\t\twas = vector<int>(n, 0);\n\t\tg.resize(n);\n\t\tres = 0;\n\t\titer = 0;\n\t}\n\tvoid add(int from, int to){\n\t\tassert(0 <= from && from < n && 0 <= to && to < m);\n\t\tg[from].push_back(to);\n\t}\n\tbool dfs(int v) {\n\t\twas[v] = iter;\n\t\tfor(int u : g[v]) {\n\t\t\tif (pb[u] == -1) {\n\t\t\t\tpa[v] = u;\n\t\t\t\tpb[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor(int u : g[v]){\n\t\t\tif(was[pb[u]] != iter && dfs(pb[u])){\n\t\t\t\tpa[v] = u;\n\t\t\t\tpb[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint solve() {\n\t\twhile(true){\n\t\t\titer++;\n\t\t\tint add = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif (pa[i] == -1 && dfs(i)){\n\t\t\t\t\tadd++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(add == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres += add;\n\t\t}\n\t\treturn res;\n\t}\n\tint run_one(int v){\n\t\tif(pa[v] != -1){\n\t\t\treturn 0;\n\t\t}\n\t\titer++;\n\t\treturn (int) dfs(v);\n\t}\n};\n\n// n = number of applicants \n// m = number of jobs\n// Applicants are enumerated as [0,1,2,...,n-1]\n// Jobs are enumerated as [0,1,2,...,m-1]\n\n// pa[i] = Job alotted to ith Applicant\n// pb[i] = Applicant alotted to ith Job\n\n// !!! REMEMBER 0-BASED INDEXING !!!\n
blossom=template <typename T = int>\nclass blossom {\n  public:\n\tstruct edge {\n\t\tint from;\n\t\tint to;\n\t\tT cost;\n    };\n\tvector<edge> edges;\n\tvector< vector<int> > g;\n\tint n;\n\tblossom(int _n) : n(_n) {\n\t\tg.resize(n);\n\t}\n\tint add_edge(int from, int to, T cost = 1) {\n\t\tassert(0 <= from && from < n && 0 <= to && to < n);\n\t\tint id = (int) edges.size();\n\t\tg[from].push_back(id);\n\t\tg[to].push_back(id);\n\t\tedges.push_back({from, to, cost});\n\t\treturn id;\n\t}\n\tvector<int> max_matching(){\n\t\tvector<int> mate(n, -1);\n\t\tvector<int> label(n);\n\t\tvector<int> parent(n);\n\t\tvector<int> orig(n);\n\t\tqueue<int> q;\n\t\tvector<int> aux(n, -1);\n\t\tint aux_time = -1;\n\t\tauto lca = [&](int x, int y) {\n\t\t\taux_time++;\n\t\t\twhile (true) {\n\t\t\t\tif(x != -1){\n\t\t\t\t\tif(aux[x] == aux_time){\n\t\t\t\t\t\treturn x;\n\t\t\t\t\t}\n\t\t\t\t\taux[x] = aux_time;\n\t\t\t\t\tif(mate[x] == -1){\n\t\t\t\t\t\tx = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tx = orig[parent[mate[x]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswap(x, y);\n\t\t\t}\n\t\t};\n\t\tauto go_blossom = [&](int v, int w, int a){\n\t\t\twhile (orig[v] != a) {\n\t\t\t\tparent[v] = w;\n\t\t\t\tw = mate[v];\n\t\t\t\tif(label[w] == 1){\n\t\t\t\t\tlabel[w] = 0;\n\t\t\t\t\tq.push(w);\n\t\t\t\t}\n\t\t\t\torig[v] = orig[w] = a;\n\t\t\t\tv = parent[w];\n\t\t\t}\n\t\t};\n\t\tauto augment = [&](int v) {\n\t\t\twhile(v != -1){\n\t\t\t\tint pv = parent[v];\n\t\t\t\tint nv = mate[pv];\n\t\t\t\tmate[v] = pv;\n\t\t\t\tmate[pv] = v;\n\t\t\t\tv = nv;\n\t\t\t}\n\t\t};\n\t\tauto bfs = [&](int root){\n\t\t\tfill(label.begin(), label.end(), -1);\n\t\t\tiota(orig.begin(), orig.end(), 0);\n\t\t\twhile(!q.empty()){\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tq.push(root);\n\t\t\tlabel[root] = 0;\n\t\t\twhile (!q.empty()){\n\t\t\t\tint v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor(int id : g[v]){\n\t\t\t\t\tauto &e = edges[id];\n\t\t\t\t\tint x = e.from ^ e.to ^ v;\n\t\t\t\t\tif(label[x] == -1){\n\t\t\t\t\t\tlabel[x] = 1;\n\t\t\t\t\t\tparent[x] = v;\n\t\t\t\t\t\tif(mate[x] == -1){\n\t\t\t\t\t\t\taugment(x);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlabel[mate[x]] = 0;\n\t\t\t\t\t\tq.push(mate[x]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(label[x] == 0 && orig[v] != orig[x]){\n\t\t\t\t\t\tint a = lca(orig[v], orig[x]);\n\t\t\t\t\t\tgo_blossom(x, v, a);\n\t\t\t\t\t\tgo_blossom(v, x, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tauto greedy = [&]() {\n\t\t\tvector<int> order(n);\n\t\t\tiota(order.begin(), order.end(), 0);\n\t\t\tshuffle(order.begin(), order.end(), mt19937(787788));\n\t\t\tfor(int i : order){\n\t\t\t\tif(mate[i] == -1){\n\t\t\t\t\tfor(int id : g[i]){\n\t\t\t\t\t\tauto &e = edges[id];\n\t\t\t\t\t\tint to = e.from ^ e.to ^ i;\n\t\t\t\t\t\tif(mate[to] == -1){\n\t\t\t\t\t\t\tmate[i] = to;\n\t\t\t\t\t\t\tmate[to] = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tgreedy();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(mate[i] == -1){\n\t\t\t\tbfs(i);\n\t\t\t}\n\t\t}\n\t\treturn mate;\n\t}\n};\n
mst=struct dsu{\n\tint n;\n\tvector<int> parent;\n\tvector<int> siz;\n\tdsu(int sz) : n(sz){\n\t\tparent.resize(n);\n\t\tsiz.resize(n,1);\n\t\tiota(parent.begin(),parent.end(), 0);\n\t}\n\tbool cmp(int a, int b){ // Give indices here\n\t\treturn siz[a] < siz[b];\n\t}\n\tinline int find(int x){ // Give index here\n\t\treturn (x == parent[x] ? x : (parent[x] = find(parent[x])));\n\t}\n\tinline bool combine(int a, int b){ // Give indices here, (returns true if a and b are in different sets)\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a != b){\n\t\t\tif(cmp(a,b))swap(a,b);\n\t\t\tparent[b] = a;\n\t\t\tsiz[a] += siz[b];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvector<vector<pair<int,int>>> mst(vector<vector<pair<int,int>>> &adj){ // Undirected minimum spanning tree of undirected graph\n\tint n = adj.size();\n\tvector<vector<int>> edg;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(auto x : adj[i]){\n\t\t\tedg.push_back({x.second,i,x.first});\n\t\t}\n\t}\n\tsort(edg.begin(),edg.end());\n\tdsu uf(n);\n\tvector<vector<pair<int,int>>> ret(n);\n\tfor(auto p : edg){\n\t\tif(uf.combine(p[1],p[2])){\n\t\t\tret[p[1]].push_back({p[2],p[0]});\n\t\t\tret[p[2]].push_back({p[1],p[0]});\n\t\t}\n\t}\n\treturn ret;\n}\n
kmp=bool sub(string pat, string txt){\n\tint M = pat.size();\n\tint N = txt.size();\n\tint lps[M];\n\tauto compute = [&](){\n\t\tint len = 0;\n\t\tlps[0] = 0;\n\t\tint i = 1;\n\t\twhile (i < M){\n\t\t\tif (pat[i] == pat[len]) {\n\t\t\t\tlen++;\n\t\t\t\tlps[i] = len;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (len != 0){\n\t\t\t\t\tlen = lps[len - 1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlps[i] = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tcompute();\n\tint i = 0,j = 0;\n\twhile (i < N) {\n\t\tif (pat[j] == txt[i]){\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\tif (j == M){\n\t\t\t//Found pattern at index (i - j)\n\t\t\treturn true;\n\t\t\tj = lps[j - 1];\n\t\t}\n\t\telse if (i < N && pat[j] != txt[i]) {\n\t\t\tif (j != 0)j = lps[j - 1];\n\t\t\telse i = i + 1;\n\t\t}\n\t}\n\treturn false;\n}\n
exgcd=array<int,3> exgcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn {a, 1, 0};\n\t}\n\tauto [g, x, y] = exgcd(b, a % b);\n\treturn {g, y, x - a / b * y};\n}\n
sieve=vector<bool> prime;\nvoid sieve(int n_n = 1000000){\n\tprime.resize(n_n+5,true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i*i <= n_n; i++){\n\t\tif(!prime[i])continue;\n\t\tfor(int j = 2; i*j <= n_n; j++){\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n}\n
factor=const int N = %cursor%;\nvector<int> smallest_factor;\nvector<bool> prime;\nvector<int> primes;\nvoid prep(int maximum = N){\n\tmaximum = max(maximum, 1);\n\tsmallest_factor.assign(maximum + 1, 0);\n\tprime.assign(maximum + 1, true);\n\tprime[0] = prime[1] = false;\n\tprimes = {};\n\tfor(int p = 2;p <= maximum; p++){\n\t\tif(prime[p]) {\n\t\t\tsmallest_factor[p] = p;\n\t\t\tprimes.push_back(p);\n\t\t\tfor(int64_t i = (int64_t)(p) * p; i <= maximum; i += p){\n\t\t\t\tif (prime[i]) {\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t\tsmallest_factor[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// Prime factorizes n in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).\n// If we've run `sieve` up to at least n, takes O(log n) time.\nvector<pair<int64_t, int>> prime_factorize(int64_t n){ // Prime,exponent\n\tint64_t sieve_max = (int64_t)(smallest_factor.size()) - 1;\n\tassert(1 <= n && n <= sieve_max * sieve_max);\n\tvector<pair<int64_t, int>> result;\n\tif(n <= sieve_max){\n\t\twhile(n != 1){\n\t\t\tint64_t p = smallest_factor[n];\n\t\t\tint exponent = 0;\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\texponent++;\n\t\t\t} while (n % p == 0);\n\t\t\tresult.emplace_back(p, exponent);\n\t\t}\n\t\treturn result;\n\t}\n\tfor(int64_t p : primes){\n\t\tif(p * p > n)\n\t\t\tbreak;\n\t\tif(n % p == 0){\n\t\t\tresult.emplace_back(p, 0);\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\tresult.back().second++;\n\t\t\t} while (n % p == 0);\n\t\t}\n\t}\n\tif(n > 1)\n\t\tresult.emplace_back(n, 1);\n\treturn result;\n}\n\nvector<int64_t> get_factors(const vector<pair<int64_t,int>> &pf){\n\tvector<int64_t> res;\n\t\n\tfunction<void(int,int64_t)> dfs = [&](int yet,int i){\n\t\tif(i == (int)pf.size()){\n\t\t\tres.push_back(yet);\n\t\t\treturn;\n\t\t}\n\t\tfor(int x = 0;x <= pf[i].second;x++){\n\t\t\tdfs(yet,i+1);\n\t\t\tyet *= pf[i].first;\n\t\t}\n\t}; dfs(1,0);\n\tsort(res.begin(),res.end());\n\treturn res;\n}\nvector<int64_t> get_factors(int x){\n\treturn get_factors(prime_factorize(x));\n}\n\nvector<pair<int64_t,int>> combine(const vector<pair<int64_t,int>> &pf1,const vector<pair<int64_t,int>> &pf2){\n\tvector<pair<int64_t, int>> res;\n\tint n = pf1.size(),m = pf2.size();\n\tint i = 0,j = 0;\n\twhile(i < n || j < m){\n\t\tif(i == n){\n\t\t\tres.push_back(pf2[j++]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(j == m){\n\t\t\tres.push_back(pf1[i++]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(pf1[i].first == pf2[j].first){\n\t\t\tres.push_back({pf1[i].first,pf1[i].second + pf2[j].second});\n\t\t\ti++;j++;\n\t\t}\n\t\telse{\n\t\t\tres.push_back(pf1[i].first < pf2[j].first ? pf1[i++] : pf2[j++]);\n\t\t}\n\t}\n\treturn res;\n}\n
fft=using cd = complex<double>;\nconst double PI = acos(-1);\n\nint reverse(int num, int lg_n) {\n    int res = 0;\n    for (int i = 0; i < lg_n; i++) {\n        if (num & (1 << i))\n            res |= 1 << (lg_n - 1 - i);\n    }\n    return res;\n}\n\nvoid fft(vector<cd> & a, bool invert) {\n\tint n = a.size();\n\tint lg_n = 0;\n\twhile ((1 << lg_n) < n)\n\t\tlg_n++;\n\tfor(int i = 0;i < n;i++) {\n\t\tif (i < reverse(i, lg_n))\n\t\t\tswap(a[i], a[reverse(i, lg_n)]);\n\t}\n\tfor(int len = 2;len <= n;len <<= 1){\n\t\tdouble ang = 2 * PI / len * (invert ? -1 : 1);\n\t\tcd wlen(cos(ang), sin(ang));\n\t\tfor (int i = 0;i < n;i += len){\n\t\t\tcd w(1);\n\t\t\tfor (int j = 0; j < len / 2; j++) {\n\t\t\t\tcd u = a[i+j], v = a[i+j+len/2] * w;\n\t\t\t\ta[i+j] = u + v;\n\t\t\t\ta[i+j+len/2] = u - v;\n\t\t\t\tw *= wlen;\n\t\t\t}\n\t\t}\n\t}\n\tif(invert){\n\t\tfor(cd &x : a)\n\t\t\tx /= n;\n\t}\n}\n\n\nvector<int> multiply(vector<int> const& a, vector<int> const& b){\n\tvector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());\n\tint n = 1;\n\twhile (n < (int)a.size() + (int)b.size()) \n\t\tn <<= 1;\n\tfa.resize(n);\n\tfb.resize(n);\n\t\n\tfft(fa, false);\n\tfft(fb, false);\n\tfor (int i = 0; i < n; i++)\n\t\tfa[i] *= fb[i];\n\tfft(fa, true);\n\t\n\tvector<int> result(n);\n\tfor (int i = 0; i < n; i++)\n\t\tresult[i] = round(fa[i].real());\n\t/* \n\t// Use this for long number muliplication. Numbers in reverse order\n\tint carry = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tresult[i] += carry;\n\t\tcarry = result[i] / 10;\n\t\tresult[i] %= 10;\n\t}\n\t*/\n\t\n\treturn result;\n}\n
ntt=template <typename T>\nclass NTT {\n public:\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tstatic Type md;\n\tstatic Modular<T> root;\n\tstatic int base;\n\tstatic int max_base;\n\tstatic vector<Modular<T>> roots;\n\tstatic vector<int> rev;\n\tstatic void clear() {\n\t\troot = 0;\n\t\tbase = 0;\n\t\tmax_base = 0;\n\t\troots.clear();\n\t\trev.clear();\n\t}\n\tstatic void init() {\n\t\tmd = T::value;\n\t\tassert(md >= 3 && md % 2 == 1);\n\t\tauto tmp = md - 1;\n\t\tmax_base = 0;\n\t\twhile (tmp % 2 == 0) {\n\t\t\ttmp /= 2;\n\t\t\tmax_base++;\n\t\t}\n\t\troot = 2;\n\t\twhile (power(root, (md - 1) >> 1) == 1) {\n\t\t\troot++;\n\t\t}\n\t\tassert(power(root, md - 1) == 1);\n\t\troot = power(root, (md - 1) >> max_base);\n\t\tbase = 1;\n\t\trev = {0, 1};\n\t\troots = {0, 1};\n\t}\n\tstatic void ensure_base(int nbase) {\n\t\tif (md != T::value) {\n\t\t\tclear();\n\t\t}\n\t\tif (roots.empty()) {\n\t\t\tinit();\n\t\t}\n\t\tif (nbase <= base) {\n\t\t\treturn;\n\t\t}\n\t\tassert(nbase <= max_base);\n\t\trev.resize(1 << nbase);\n\t\tfor (int i = 0; i < (1 << nbase); i++) {\n\t\t\trev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n\t\t}\n\t\troots.resize(1 << nbase);\n\t\twhile (base < nbase) {\n\t\t\tModular<T> z = power(root, 1 << (max_base - 1 - base));\n\t\t\tfor (int i = 1 << (base - 1); i < (1 << base); i++) {\n\t\t\t\troots[i << 1] = roots[i];\n\t\t\t\troots[(i << 1) + 1] = roots[i] * z;\n\t\t\t}\n\t\t\tbase++;\n\t\t}\n\t}\n\tstatic void fft(vector<Modular<T>> &a) {\n\t\tint n = (int) a.size();\n\t\tassert((n & (n - 1)) == 0);\n\t\tint zeros = __builtin_ctz(n);\n\t\tensure_base(zeros);\n\t\tint shift = base - zeros;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif (i < (rev[i] >> shift)) {\n\t\t\t\tswap(a[i], a[rev[i] >> shift]);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1; k < n; k <<= 1) {\n\t\t\tfor (int i = 0; i < n; i += 2 * k) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tModular<T> x = a[i + j];\n\t\t\t\t\tModular<T> y = a[i + j + k] * roots[j + k];\n\t\t\t\t\ta[i + j] = x + y;\n\t\t\t\t\ta[i + j + k] = x - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n\t\tif(a.empty() || b.empty()) {\n\t\t\treturn {};\n\t\t}\n\t\tint eq = (a == b);\n\t\tint need = (int) a.size() + (int) b.size() - 1;\n\t\tint nbase = 0;\n\t\twhile ((1 << nbase) < need) nbase++;\n\t\tensure_base(nbase);\n\t\tint sz = 1 << nbase;\n\t\ta.resize(sz);\n\t\tb.resize(sz);\n\t\tfft(a);\n\t\tif (eq) b = a; else fft(b);\n\t\tModular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\ta[i] *= b[i] * inv_sz;\n\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfft(a);\n\t\ta.resize(need);\n\t\treturn a;\n\t}\n};\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n\tassert(!a.empty());\n\tint n = (int) a.size();\n\tvector<Modular<T>> b = {1 / a[0]};\n\twhile((int) b.size() < n){\n\t\tvector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n\t\tx.resize(b.size() << 1);\n\t\tb.resize(b.size() << 1);\n\t\tvector<Modular<T>> c = b;\n\t\tNTT<T>::fft(c);\n\t\tNTT<T>::fft(x);\n\t\tModular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n\t\tfor(int i = 0; i < (int) x.size(); i++){\n\t\t\tx[i] *= c[i] * inv;\n\t\t}\n\t\treverse(x.begin() + 1, x.end());\n\t\tNTT<T>::fft(x);\n\t\trotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n\t\tfill(x.begin() + (x.size() >> 1), x.end(), 0);\n\t\tNTT<T>::fft(x);\n\t\tfor(int i = 0; i < (int) x.size(); i++){\n\t\t\tx[i] *= c[i] * inv;\n\t\t}\n\t\treverse(x.begin() + 1, x.end());\n\t\tNTT<T>::fft(x);\n\t\tfor(int i = 0; i < ((int) x.size() >> 1); i++){\n\t\t\tb[i + ((int) x.size() >> 1)] = -x[i];\n\t\t}\n\t}\n\tb.resize(n);\n\treturn b;\n}\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n\tassert(!a.empty());\n\tint n = (int) a.size();\n\tif(n == 1){\n\t\treturn {1 / a[0]};\n\t}\n\tint m = (n + 1) >> 1;\n\tvector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n\tint need = n << 1;\n\tint nbase = 0;\n\twhile((1 << nbase) < need) {\n\t\t++nbase;\n\t}\n\tNTT<T>::ensure_base(nbase);\n\tint size = 1 << nbase;\n\ta.resize(size);\n\tb.resize(size);\n\tNTT<T>::fft(a);\n\tNTT<T>::fft(b);\n\tModular<T> inv = 1 / static_cast<Modular<T>>(size);\n\tfor(int i = 0; i < size; ++i){\n\t\ta[i] = (2 - a[i] * b[i]) * b[i] * inv;\n\t}\n\treverse(a.begin() + 1, a.end());\n\tNTT<T>::fft(a);\n\ta.resize(n);\n\treturn a;\n}\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n\tif(a.empty() || b.empty()){\n\t\treturn {};\n\t}\n\tif(min(a.size(), b.size()) < 150){\n\t\tvector<Modular<T>> c(a.size() + b.size() - 1, 0);\n\t\tfor (int i = 0; i < (int) a.size(); i++) {\n\t\t\tfor (int j = 0; j < (int) b.size(); j++){\n\t\t\t\tc[i + j] += a[i] * b[j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\treturn NTT<T>::multiply(a, b);\n}\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n\treturn a = a * b;\n}\n// Needs Modular\n
traverse=vector<int> Enter,Exit,order;\nvoid traverse(vector<vector<int>> &adj,int root = 0){\n\tint V = adj.size();\n\torder.clear();\n\tEnter.clear();Enter.resize(V);\n\tExit.clear();Exit.resize(V);\n\tint travel_time = 0;\n\tfunction<void(int,int)> traverse_tree = [&](int i, int parent){\n\t\torder.push_back(i);\n\t\tEnter[i] = travel_time++;\n\t\tfor(int node : adj[i]){\n\t\t\tif(node != parent){\n\t\t\t\ttraverse_tree(node,i);\n\t\t\t}\n\t\t}\n\t\tExit[i] = travel_time++;\n\t};traverse_tree(root,-1);\n}\n\nbool anc(int child, int ancestor){ // If ansector is an ancestor of child\n\treturn Enter[ancestor] < Enter[child] && Exit[child] < Exit[ancestor];\n}\n
scc=vector<vector<int>> scc;\nvector<int> comp;\n\nvoid SCC(vector<vector<int>> &adj){\n\tscc.clear();comp.clear();\n\tint V = adj.size();\n\tcomp.resize(V);\n\tvector<int> disc(V);\n\tvector<int> low(V);\n\tvector<bool> stackMember(V);\n\tstack<int> st;\n\tfor (int i = 0; i < V; i++){\n\t\tdisc[i] = -1;\n\t\tlow[i] = -1;\n\t\tstackMember[i] = false;\n\t}\n\tstatic int time = 0;\n\tfunction<void(int)> find_scc = [&](int u){\n\t\tdisc[u] = low[u] = ++time;\n\t\tst.push(u);\n\t\tstackMember[u] = true;\n\t\tfor (auto i = adj[u].begin(); i != adj[u].end(); ++i){\n\t\t\tint v = *i;\n\t\t\tif (disc[v] == -1){\n\t\t\t\tfind_scc(v);\n\t\t\t\tlow[u]  = min(low[u], low[v]);\n\t\t\t}\n\t\t\telse if (stackMember[v])\n\t\t\t\tlow[u]  = min(low[u], disc[v]);\n\t\t}\n\t\tint w = 0;\n\t\tif (low[u] == disc[u]){\n\t\t\tvector<int> row;\n\t\t\tint ID = scc.size();\n\t\t\twhile (st.top() != u){\n\t\t\t\tw = (int) st.top();\n\t\t\t\trow.push_back(w);\n\t\t\t\tcomp[w] = ID;\n\t\t\t\tstackMember[w] = false;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tw = (int) st.top();\n\t\t\trow.push_back(w);\n\t\t\tcomp[w] = ID;\n\t\t\tscc.push_back(row);\n\t\t\tstackMember[w] = false;\n\t\t\tst.pop();\n\t\t}\n\t};\n\tfor (int i = 0; i < V; i++){\n\t\tif (disc[i] == -1)find_scc(i);\n\t}\n}\n\n// Call this immediately after SCC to get the compressed graph\n\nvector<vector<int>> build_graph(const vector<vector<int>> &adj){ \n\tint n = adj.size();\n\tvector<vector<int>> scc_graph(scc.size());\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int x : adj[i]){\n\t\t\tif(comp[i] != comp[x]){\n\t\t\t\tscc_graph[comp[i]].push_back(comp[x]);\n\t\t\t}\n\t\t}\n\t}\n\treturn scc_graph;\n}\n
toposort=vector<int> toposort(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tstack<int> Stack;\n\tvector<bool> visited(V,false);\n\tfunction<void(int)> toposort = [&](int v) -> void {\n\t\tvisited[v] = true;\n\t\tfor(auto i : adj[v])\n\t\t\tif(!visited[i])\n\t\t\t\ttoposort(i);\n\t\tStack.push(v);\n\t};\n\tfor(int i = 0; i < V; i++)\n\t\tif (!visited[i])\n\t\t\ttoposort(i);\n\tvector<int> ans;\n\twhile(!Stack.empty()) {\n\t\tans.push_back(Stack.top());\n\t\tStack.pop();\n\t}\n\treturn ans;\n}\n
cycleu=//This detects cycle in an ***undirected graph***\nvector<int> cyc;\nbool isCyclic(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tvector<bool> visited(V);\n\tfor(int i = 0; i < V; i++){\n\t\tvisited[i] = false;\n\t}\n\tfunction<bool(int,int)> cycle = [&](int v,int parent) -> bool {\n\t\tcyc.push_back(v);\n\t\tvisited[v] = true;\n\t\tfor(int i : adj[v]){\n\t\t\tif (!visited[i]){\n\t\t\t\tif(cycle(i,v)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i != parent){\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\twhile(!cyc.empty() && cyc.back() != i)cyc.pop_back();\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcyc.pop_back();\n\t\treturn false;\n\t};\n\tfor(int i = 0; i < V; i++){\n\t\tif(!visited[i] && cycle(i,-1)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n
cycled=//This detects cycle in a ***directed graph***\nbool isCyclic(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tvector<bool> visited(V);\n\tvector<bool> recStack(V);\n\tfor(int i = 0; i < V; i++){\n\t\tvisited[i] = false;\n\t\trecStack[i] = false;\n\t}\n\tfunction<bool(int)> cycle = [&](int v){\n\t\t\tif(visited[v] == false){\n\t\t\t\tvisited[v] = true;\n\t\t\t\trecStack[v] = true;\n\t\t\t\tfor(int i : adj[v]){\n\t\t\t\t\tif (!visited[i] && cycle(i))return true;\n\t\t\t\t\telse if (recStack[i])return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trecStack[v] = false;\n\t\t\treturn false;\n\t};\n\tfor(int i = 0; i < V; i++){\n\t\tif(cycle(i))return true;\n\t}\n\treturn false;\n}\n
maxflow=template<class T>\nstruct Flow {\n\tconst int n;\n\tstruct Edge {\n\t\tint to;\n\t\tT cap;\n\t\tEdge(int _to, T _cap) : to(_to), cap(_cap) {}\n\t};\n\tstd::vector<Edge> e;\n\tstd::vector<std::vector<int>> g;\n\tstd::vector<int> cur, h;\n\tFlow(int _n) : n(_n), g(_n) {}\n\t\n\tbool bfs(int s, int t) {\n\t\th.assign(n, -1);\n\t\tstd::queue<int> que;\n\t\th[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tconst int u = que.front();\n\t\t\tque.pop();\n\t\t\tfor (int i : g[u]) {\n\t\t\t\tauto [v, c] = e[i];\n\t\t\t\tif (c > 0 && h[v] == -1) {\n\t\t\t\t\th[v] = h[u] + 1;\n\t\t\t\t\tif (v == t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tT dfs(int u, int t, T f) {\n\t\tif (u == t) {\n\t\t\treturn f;\n\t\t}\n\t\tauto r = f;\n\t\tfor (int &i = cur[u]; i < int(g[u].size()); ++i) {\n\t\t\tconst int j = g[u][i];\n\t\t\tauto [v, c] = e[j];\n\t\t\tif (c > 0 && h[v] == h[u] + 1) {\n\t\t\t\tauto a = dfs(v, t, std::min(r, c));\n\t\t\t\te[j].cap -= a;\n\t\t\t\te[j ^ 1].cap += a;\n\t\t\t\tr -= a;\n\t\t\t\tif (r == 0) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f - r;\n\t}\n\tvoid addEdge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.emplace_back(v, c);\n\t\tg[v].push_back(e.size());\n\t\te.emplace_back(u, 0);\n\t}\n\tT maxFlow(int s, int t) {\n\t\tT ans = 0;\n\t\twhile (bfs(s, t)) {\n\t\t\tcur.assign(n, 0);\n\t\t\tans += dfs(s, t, std::numeric_limits<T>::max());\n\t\t}\n\t\treturn ans;\n\t}\n};\n
mcmf=const int INF = 1e9;\nclass mcmf{\n  public:\n\tstruct Edge{\n\t\tint from, to, capacity, cost;\n\t};\n\n\tvector<vector<int>> adj, cost, capacity;\n\tvector<Edge> edges;\n\tint N;\n\t\n\tmcmf(int _n){\n\t\tN = _n;\n\t}\n\t\n\tvoid addEdge(int From,int To,int Capacity, int Cost){\n\t\tassert(From >= 0 && From < N && To >= 0 && To < N);\n\t\tedges.push_back({From,To,Capacity,Cost});\n\t}\n\t\n\tvoid shortest_paths(int n, int v0, vector<int>& d, vector<int>& p) {\n\t\td.assign(n, INF);\n\t\td[v0] = 0;\n\t\tvector<bool> inq(n, false);\n\t\tqueue<int> q;\n\t\tq.push(v0);\n\t\tp.assign(n, -1);\n\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tinq[u] = false;\n\t\t\tfor (int v : adj[u]) {\n\t\t\t\tif (capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]) {\n\t\t\t\t\td[v] = d[u] + cost[u][v];\n\t\t\t\t\tp[v] = u;\n\t\t\t\t\tif (!inq[v]) {\n\t\t\t\t\t\tinq[v] = true;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint min_cost_flow(int s, int t,int K = INF) {\n\t\tadj.assign(N, vector<int>());\n\t\tcost.assign(N, vector<int>(N, 0));\n\t\tcapacity.assign(N, vector<int>(N, 0));\n\t\tfor (Edge e : edges) {\n\t\t\tadj[e.from].push_back(e.to);\n\t\t\tadj[e.to].push_back(e.from);\n\t\t\tcost[e.from][e.to] = e.cost;\n\t\t\tcost[e.to][e.from] = -e.cost;\n\t\t\tcapacity[e.from][e.to] = e.capacity;\n\t\t}\n\n\t\tint flow = 0;\n\t\tint Cost = 0;\n\t\tvector<int> d, p;\n\t\twhile (flow < K) {\n\t\t\tshortest_paths(N, s, d, p);\n\t\t\tif (d[t] == INF)\n\t\t\t\tbreak;\n\n\t\t\t// find max flow on that path\n\t\t\tint f = K - flow;\n\t\t\tint cur = t;\n\t\t\twhile (cur != s) {\n\t\t\t\tf = min(f, capacity[p[cur]][cur]);\n\t\t\t\tcur = p[cur];\n\t\t\t}\n\n\t\t\t// apply flow\n\t\t\tflow += f;\n\t\t\tCost += f * d[t];\n\t\t\tcur = t;\n\t\t\twhile (cur != s) {\n\t\t\t\tcapacity[p[cur]][cur] -= f;\n\t\t\t\tcapacity[cur][p[cur]] += f;\n\t\t\t\tcur = p[cur];\n\t\t\t}\n\t\t}\n\n\t\tif (flow < K && K != INF)\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn Cost;\n\t}\n};\n// Finds minimum cost for a flow of K units\n// Set K == INF if minimum cost for maximum flow is required\n// Complexity - O(n^2 . m^2)\n
power=int64_t power(int64_t x, int64_t y){\n\tint64_t res = 1;\n\tx = x % mod;\n\tif (x == 0) return 0;\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\n
ncr=const int MXN = %cursor%;\nconst ll mod = %cursor%;\nll fac[MXN],invfac[MXN];\nll power(ll x, ll y){\n\tll res = 1;\n\tx = x % mod;\n\tif (x == 0) return 0;\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\nvoid prep(){ // Don't forget to call this\n\tfac[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfac[i] = fac[i-1]*i;\n\t\tfac[i] %= mod;\n\t}\n\tinvfac[MXN-1] = power(fac[MXN-1],mod-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinvfac[i] = invfac[i+1]*(i+1);\n\t\tinvfac[i] %= mod;\n\t}\n}\nll C(int n,int r){\n\tif(n < r)return 0;\n\treturn ((fac[n]*invfac[r])%mod * invfac[n-r])%mod;\n}\n
zfun=vector<int> z_function(string s) {\n\tint n = (int) s.length();\n\tvector<int> z(n);\n\tfor (int i = 1, l = 0, r = 0; i < n; ++i) {\n\t\tif (i <= r)\n\t\t\tz[i] = min (r - i + 1, z[i - l]);\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]])\n\t\t\t++z[i];\n\t\tif (i + z[i] - 1 > r)\n\t\t\tl = i, r = i + z[i] - 1;\n\t}\n\treturn z;\n}\n
suffix=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n
lcp=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n\n \nvector<int> lcp(string txt){\n\tint n = txt.size();\n\tvector<int> lcp(n, 0);\n\tvector<int> invSuff(n, 0);\n\tvector<int> suffixArr = suffix_array(txt);\n\tfor(int i = 0; i < n; i++)\n\t\tinvSuff[suffixArr[i]] = i;\n\tint k = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (invSuff[i] == n-1){\n\t\t\tk = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = suffixArr[invSuff[i]+1];\n\t\twhile (i+k<n && j+k<n && txt[i+k]==txt[j+k])\n\t\t\tk++;\n\t\tlcp[invSuff[i]] = k;\n\t\tk -= k > 0;\n\t}\n\treturn lcp;\n}\n

# One line shorthands
f=first
s=second
b=begin()
e=end()
be=%cursor%.begin(),%cursor%.end()
find=find(%cursor%) != %cursor%.end()
nfind=find(%cursor%) == %cursor%.end()
re=resize(%cursor%);
pb=push_back
mp=make_pair
ppb=pop_back()
sort=sort(%cursor%.begin(),%cursor%.end());
rsort=sort(%cursor%.rbegin(),%cursor%.rend());
sortcst=sort(%cursor%.begin(),%cursor%.end(),[&](const auto &v1,const auto &v2){\n\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n});\n
reverse=reverse(%cursor%.begin(),%cursor%.end());
iota=iota(%cursor%.begin(),%cursor%.end(),%cursor%);
unique=%cursor%.erase(unique(%cursor%.begin(), %cursor%.end()), %cursor%.end()); // Vector MUST be sorted
lb=lower_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value >= val\n
ub=upper_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value > val\n
dxdy=vector<int> dx = {-1,1,0,0};\nvector<int> dy = {0,0,1,-1};\n
fast=ios::sync_with_stdio(false);cin.tie(0);
skl=#ifdef shivang_ka_laptop\n\t%cursor%\n#endif\n
dbg=#ifdef dbg\n\t%cursor%\n#else\n\t%cursor%\n#endif\n
uskl=#undef shivang_ka_laptop\n
todo=#pragma message("%cursor%")
hhm=//Har Har Mahadev

[Kotlin]
test=import java.lang.AssertionError\n\nprivate fun readLn() = readLine()!! // string line\nprivate fun readInt() = readLn().toInt() // single int\nprivate fun readLong() = readLn().toLong() // single long\nprivate fun readDouble() = readLn().toDouble() // single double\nprivate fun readStrings() = readLn().split(" ") // list of strings\nprivate fun readInts() = readStrings().map { it.toInt() } // list of ints\nprivate fun readLongs() = readStrings().map { it.toLong() } // list of longs\nprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles\n\nprivate fun myAssert(x: Boolean) {\n    if (!x) {\n        throw AssertionError()\n    }\n}\n\nfun testcase(){\n\t%cursor%\n}\n\nfun main() {\n\tvar tt = readInt()\n    for (qq in 0 until tt) {\n        testcase()\n    }\n}\n
vi=var %cursor%: MutableList<Int> = mutableListOf<Int>()
vs=var %cursor%: MutableList<String> = mutableListOf<String>()
for=for(i in 0 .. %cursor%-1){\n\t\n}\n
[Python]
for=for i in range(%cursor%):\n\t
forj=for j in range(%cursor%):\n\t
fork=for k in range(%cursor%):\n\t
